module 査読者割当exports alldefinitionstypes    名称型 = seq1 of char;    研究者型 = token;    論文型 :: タイトル : 名称型 著者 : set1 of 研究者型;    査読割当型 :: 論文 : 論文型 査読者 : 研究者型;    査読希望型 =        <査読したい> | <査読してもよい> | <査読したくない> | <利益相反>;    査読コスト型 = real;values    論文あたり査読者数初期値 = 3;    査読候補者希望 =        {<査読したい>, <査読してもよい>, <査読したくない>, <利益相反>};state 査読者割当 of    論文あたり査読者数 : nat1    コスト表 : map 査読希望型 to 査読コスト型    査読者リスト : set of 研究者型    査読論文リスト : set of 論文型    希望表 : map 研究者型 to (map 論文型 to 査読希望型)    割当リスト : set of 査読割当型inv mk_査読者割当(    -, -, 仮査読者リスト, 仮査読論文リスト, 仮希望表, 仮割当リスト) ==    {割当.査読者 | 割当 in set 仮割当リスト} subset 仮査読者リストinit 初期状態 ==    初期状態    = mk_査読者割当(論文あたり査読者数初期値, {|->}, {}, {}, {|->}, {})endoperations    pure 利益相反リスト : set of 査読割当型 ==> set of 査読割当型    利益相反リスト(仮割当表) ==        return {割当 | 割当 in set 仮割当表 & 利益相反(割当)}    post         RESULT subset 仮割当表        and (forall 割当 in set 仮割当表 &                利益相反(割当) <=> 割当 in set RESULT);    pure 査読者不足リスト : set of 査読割当型 ==> set of 論文型    査読者不足リスト(仮割当リスト) ==        return {論文 | 論文 in set 査読論文リスト                & card {査読者 | mk_査読割当型((論文), 査読者) in set 仮割当リスト}                < 論文あたり査読者数}    post         RESULT subset 査読論文リスト        and (forall 論文 in set 査読論文リスト &                card {査読者 | mk_査読割当型((論文), 査読者) in set 仮割当リスト}                < 論文あたり査読者数                <=> 論文 in set RESULT);    pure 総査読コスト : set of 査読割当型 ==> 査読コスト型    総査読コスト(仮割当リスト) ==        (dcl コスト計:査読コスト型 := 0;        for all 割当 in set 仮割当リスト do コスト計 := コスト計 + 査読コスト(割当);        return コスト計);    pure 最大コスト差 : set of 査読割当型 ==> 査読コスト型    最大コスト差(仮割当表) ==        let            コストリスト : set of 査読コスト型 =                {査読者コスト(査読者, 仮割当表) | 査読者 in set 査読者リスト}        in            return if コストリスト = {} then 0 else 最大値(コストリスト) - 最小値(コストリスト);functions    査読者不足 : set of 研究者型 * nat1 -> bool    査読者不足(査読者リスト, 査読者数) == card 査読者リスト < 査読者数;operations    pure 利益相反 : 査読割当型 ==> bool    利益相反(mk_査読割当型(論文, 査読者)) ==        return 査読者 in set 論文.著者            or (査読者 in set dom 希望表 and 論文 in set dom 希望表(査読者))            and 希望表(査読者)(論文) = <利益相反>;    pure 査読者コスト : 研究者型 * set of 査読割当型 ==> 査読コスト型    査読者コスト(査読者, 仮割当リスト) ==        return 総査読コスト(                {割当 | 割当 in set 仮割当リスト & 割当.査読者 = 査読者});    pure 査読コスト : 査読割当型 ==> 査読コスト型    査読コスト(mk_査読割当型(論文, 査読者)) ==        (if            査読者 in set dom 希望表        then            let 個人コスト表 = コスト表 comp (希望表(査読者))            in if 論文 in set dom 個人コスト表 then return 個人コスト表(論文);        return 0);    pure 査読論文数 : 研究者型 * set of 査読割当型 ==> nat    査読論文数(査読者, 仮割当リスト) ==        return card {論文 | mk_査読割当型(論文, (査読者)) in set 仮割当リスト};functions    最大値 : set1 of real -> real    最大値(xs) == iota x in set xs & (forall y in set xs & y <= x);    最小値 : set1 of real -> real    最小値(xs) == iota x in set xs & (forall y in set xs & x <= y);end 査読者割当