module 査読割当規則
exports
    types
        名称型;
        研究者型;
        struct 論文型;
        struct 査読割当型;
    functions
        利益相反リスト
            : set of 査読割当型 * set of 査読割当型 -> set of 査読割当型;
        査読者不足リスト
            : set of 論文型 * nat1 * set of 査読割当型 -> set of 論文型;
definitions
types
    名称型 = seq1 of char;
    研究者型 = token;
    論文型 :: タイトル : 名称型 著者 : set1 of 研究者型;
    査読割当型 :: 論文 : 論文型 査読者 : 研究者型;
functions
    利益相反リスト : set of 査読割当型 * set of 査読割当型 -> set of 査読割当型
    利益相反リスト(利益相反申告リスト, 割当リスト) ==
        {割当 | 割当 in set 割当リスト
            & 割当 in set 利益相反申告リスト or 利益相反(割当)}
    post ((RESULT subset 割当リスト
            and 割当リスト inter 利益相反申告リスト subset RESULT)
        and (forall 割当 in set RESULT \ 利益相反申告リスト & 利益相反(割当)))
    and (forall 割当 in set 割当リスト &
            利益相反(割当) => 割当 in set RESULT);
    査読者不足リスト : set of 論文型 * nat1 * set of 査読割当型 -> set of 論文型
    査読者不足リスト(論文リスト, 論文あたり査読者数, 割当リスト) ==
        {論文 | 論文 in set 論文リスト
            & 査読者数(論文, 割当リスト) < 論文あたり査読者数}
    post RESULT subset 論文リスト
    and ((forall 論文 in set RESULT &
                査読者数(論文, 割当リスト) < 論文あたり査読者数)
        and (forall 論文 in set 論文リスト \ RESULT &
                査読者数(論文, 割当リスト) >= 論文あたり査読者数));
functions
    利益相反 : 査読割当型 -> bool
    利益相反(mk_査読割当型(論文, 査読者)) == 査読者 in set 論文.著者;
    査読者数 : 論文型 * set of 査読割当型 -> nat
    査読者数(論文, 割当リスト) ==
        card {査読者 | mk_査読割当型((論文), 査読者) in set 割当リスト};
end 査読割当規則