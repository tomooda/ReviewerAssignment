module 査読割当規則
exports all
definitions
types
    名称型 = seq1 of char;
    研究者型 = token;
    論文型 :: タイトル : 名称型 著者 : set1 of 研究者型;
    査読割当型 :: 論文 : 論文型 査読者 : 研究者型;
    査読コスト型 = real;
operations
    pure 利益相反リスト : set of 査読割当型 * set of 査読割当型 ==> set of 査読割当型
    利益相反リスト(利益相反申告リスト, 割当リスト) ==
        return {割当 | 割当 in set 割当リスト
                & 割当 in set 利益相反申告リスト or 利益相反(割当)}
    post 
        ((RESULT subset 割当リスト
                and 割当リスト inter 利益相反申告リスト subset RESULT)
            and (forall 割当 in set RESULT \ 利益相反申告リスト & 利益相反(割当)))
        and (forall 割当 in set 割当リスト &
                利益相反(割当) => 割当 in set RESULT);
    pure 査読者不足リスト : set of 論文型 * nat1 * set of 査読割当型 ==> set of 論文型
    査読者不足リスト(論文リスト, 論文あたり査読者数, 割当リスト) ==
        return {論文 | 論文 in set 論文リスト
                & card {査読者 | mk_査読割当型((論文), 査読者) in set 割当リスト}
                < 論文あたり査読者数}
    post 
        RESULT subset {割当.論文 | 割当 in set 割当リスト}
        and (forall 論文 in set 論文リスト &
                card {査読者 | mk_査読割当型((論文), 査読者) in set 割当リスト}
                < 論文あたり査読者数
                <=> 論文 in set RESULT);
operations
    pure 利益相反 : 査読割当型 ==> bool
    利益相反(mk_査読割当型(論文, 査読者)) ==
        return 査読者 in set 論文.著者;
    pure 査読論文数 : 研究者型 * set of 査読割当型 ==> nat
    査読論文数(査読者, 仮割当リスト) ==
        return card {論文 | mk_査読割当型(論文, (査読者)) in set 仮割当リスト};
end 査読割当規則